# Paywall App

**1. Архитектура приложения**

Приложение использует архитектурный паттерн **MVVM (Model-View-ViewModel)**, с упрощенным подходом к управлению состоянием.

*   **View (Представление):** Экраны (`HomeScreen`, `PaywallScreen`, `OnboardingScreen`) являются `StatelessWidget`'ами, которые получают `ViewModel` через конструктор. Они отвечают за отображение UI и передачу пользовательских действий в `ViewModel`, используя `ValueListenableBuilder` для реактивного обновления UI.
*   **ViewModel (Модель представления):** `ViewModel`'ы (`HomeViewModel`, `PaywallViewModel`, `OnboardingViewModel`) содержат бизнес-логику для конкретных экранов. Они предоставляют `ValueListenable`'ы для `View` и взаимодействуют с **Репозиториями** для работы с данными.
*   **Model (Модель в контексте данных):** Представляют собой структуры данных (например, `SubscriptionInfoBase`, `SubscriptionInfo`), не содержащие бизнес-логики.
*   **Repository (Репозиторий):** `SubscriptionRepository` абстрагирует источники данных, координируя получение и сохранение данных через **Сервисы**. Он предоставляет `ValueNotifier` для отслеживания статуса подписки и расширяет `ChangeNotifier` для реактивного управления состоянием.
*   **Services (Сервисы):**
    *   `LocalStorageService`: Использует `shared_preferences` для локального хранения данных.
    *   `ApiService` (MockApiService): Абстракция для взаимодействия с API, в текущей версии используется заглушка.
*   **Навигация:** Используется пакет `go_router` для определения маршрутов и логики перенаправления. `GoRouter` настроен на реакцию на изменения статуса подписки через `refreshListenable`, обеспечивая мгновенное перенаправление.
*   **Управление зависимостями:** Используется `Provider` для внедрения `SubscriptionRepository` и управления его жизненным циклом, обеспечивая доступ к репозиторию по всему приложению без использования глобальных переменных.

**2. Структура проекта**

Проект организован по принципу разделения по слоям и типам файлов:

*   **`lib/`**:
    *   **`data/`**: Логика, связанная с данными.
        *   `models/`: Определения моделей данных.
        *   `repositories/`: Репозитории (например, `subscription_repository.dart`).
        *   `services/`: Сервисы.
            *   `api/`: Сервисы API (например, `api_service.dart`).
            *   `storage/`: Сервисы локального хранилища (например, `storage_service.dart`).
    *   **`router/`**: Конфигурация навигации (`app_router.dart`).
    *   **`ui/`**: Компоненты пользовательского интерфейса.
        *   `screens/`: Отдельные экраны приложения.
        *   `widgets/`: Переиспользуемые виджеты.
    *   **`utils/`**: Вспомогательные утилиты (`date_formatter.dart`).
    *   **`viewmodels/`**: `ViewModel`'ы для экранов.
    *   **`main.dart`**: Точка входа в приложение.

**3. Что бы я улучшил при большем времени**

1.  **Управление состоянием:**
    *   Внедрение полноценного решения для управления состоянием, такого как **Riverpod** или **BLoC/Cubit**, для лучшей масштабируемости, тестируемости и явного управления зависимостями.

2.  **Обработка ошибок и загрузки:**
    *   Реализация централизованного механизма обработки ошибок для более информативных сообщений и логирования.
    *   Стандартизация отображения индикаторов загрузки по всему приложению.

3.  **Тестирование:**
    *   Написание **Unit-тестов** для бизнес-логики в `ViewModel`'ах и репозиториях.
    *   Написание **Widget-тестов** для UI-компонентов.

4.  **Абстракции и интерфейсы:**
    *   Расширение использования абстракций для всех сервисов для облегчения их замены и тестирования.

5.  **Локализация:**
    *   Добавление поддержки нескольких языков (i18n) для всех текстовых элементов.

6.  **UI/UX:**
    *   Добавление более плавных анимаций и переходов для улучшения пользовательского опыта.
    *   Реализация более детальной обратной связи при взаимодействии с пользователем.

7.  **Безопасность:**
    *   Реализация безопасного хранения конфиденциальных данных (например, API-ключей), если они будут использоваться.
